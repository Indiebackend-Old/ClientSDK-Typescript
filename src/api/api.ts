/* tslint:disable */
/* eslint-disable */
/**
 * Indiebackend Clients API
 * Indiebackend API documentation for clients
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    appId: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    shopId: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    displayName: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    description: string;
    /**
     * 
     * @type {boolean}
     * @memberof Category
     */
    published: boolean;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    updatedAt: string;
    /**
     * 
     * @type {Array<ShopItemDto>}
     * @memberof Category
     */
    items: Array<ShopItemDto>;
}
/**
 * 
 * @export
 * @interface CheckoutItem
 */
export interface CheckoutItem {
    /**
     * 
     * @type {string}
     * @memberof CheckoutItem
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutItem
     */
    currency: string;
    /**
     * 
     * @type {number}
     * @memberof CheckoutItem
     */
    currencyAmount: number;
    /**
     * 
     * @type {string}
     * @memberof CheckoutItem
     */
    currencyType: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutItem
     */
    profile: string;
    /**
     * 
     * @type {number}
     * @memberof CheckoutItem
     */
    quantity: number;
    /**
     * 
     * @type {number}
     * @memberof CheckoutItem
     */
    unitAmount: number;
}
/**
 * 
 * @export
 * @interface CheckoutSessionCreated
 */
export interface CheckoutSessionCreated {
    /**
     * Stripe\'s checkout session id
     * @type {string}
     * @memberof CheckoutSessionCreated
     */
    sessionId: string;
    /**
     * Stripe\'s public key
     * @type {string}
     * @memberof CheckoutSessionCreated
     */
    pk: string;
    /**
     * URL to redirect to in order to complete checkout
     * @type {string}
     * @memberof CheckoutSessionCreated
     */
    redirectUrl: string;
}
/**
 * 
 * @export
 * @interface CreateCheckoutDto
 */
export interface CreateCheckoutDto {
    /**
     * 
     * @type {Array<CheckoutItem>}
     * @memberof CreateCheckoutDto
     */
    items: Array<CheckoutItem>;
}
/**
 * 
 * @export
 * @interface CreateGroupDto
 */
export interface CreateGroupDto {
    /**
     * 
     * @type {string}
     * @memberof CreateGroupDto
     */
    name: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateGroupDto
     */
    members: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof CreateGroupDto
     */
    publicData: object;
    /**
     * 
     * @type {object}
     * @memberof CreateGroupDto
     */
    privateData: object;
}
/**
 * 
 * @export
 * @interface CreateProfileDto
 */
export interface CreateProfileDto {
    /**
     * 
     * @type {string}
     * @memberof CreateProfileDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProfileDto
     */
    displayName: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProfileDto
     */
    avatarUrl: string;
}
/**
 * 
 * @export
 * @interface Currencies
 */
export interface Currencies {
    /**
     * Publicly-available currencies
     * @type {object}
     * @memberof Currencies
     */
    publicCurrencies: object;
    /**
     * Owner-accessible currencies
     * @type {object}
     * @memberof Currencies
     */
    privateCurrencies: object;
    /**
     * Internal currencies used by Indiebackend (battlepassXp, etc.)
     * @type {object}
     * @memberof Currencies
     */
    internalCurrencies: object;
}
/**
 * 
 * @export
 * @interface CurrenciesDto
 */
export interface CurrenciesDto {
    /**
     * 
     * @type {Array<CurrencyObject>}
     * @memberof CurrenciesDto
     */
    publicCurrencies: Array<CurrencyObject>;
    /**
     * 
     * @type {Array<CurrencyObject>}
     * @memberof CurrenciesDto
     */
    privateCurrencies: Array<CurrencyObject>;
}
/**
 * 
 * @export
 * @interface CurrencyObject
 */
export interface CurrencyObject {
    /**
     * 
     * @type {string}
     * @memberof CurrencyObject
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof CurrencyObject
     */
    value: number;
    /**
     * 
     * @type {boolean}
     * @memberof CurrencyObject
     */
    isIncrement: boolean;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * Group id
     * @type {string}
     * @memberof Group
     */
    id: string;
    /**
     * App Id that the group belongs to
     * @type {string}
     * @memberof Group
     */
    appId: string;
    /**
     * Name of the group
     * @type {string}
     * @memberof Group
     */
    name: string;
    /**
     * Group\'s leader
     * @type {string}
     * @memberof Group
     */
    leader: string;
    /**
     * Group\'s members
     * @type {Array<string>}
     * @memberof Group
     */
    members: Array<string>;
    /**
     * Publicly-accessible data
     * @type {object}
     * @memberof Group
     */
    publicData: object;
    /**
     * Group\'s private data (members-only)
     * @type {object}
     * @memberof Group
     */
    privateData: object;
}
/**
 * 
 * @export
 * @interface GroupDeletedDto
 */
export interface GroupDeletedDto {
    /**
     * 
     * @type {boolean}
     * @memberof GroupDeletedDto
     */
    deleted: boolean;
}
/**
 * 
 * @export
 * @interface GroupLeaveResult
 */
export interface GroupLeaveResult {
    /**
     * Updated group object
     * @type {Group}
     * @memberof GroupLeaveResult
     */
    group: Group;
    /**
     * Was the group updated by the request ?
     * @type {boolean}
     * @memberof GroupLeaveResult
     */
    updated: boolean;
    /**
     * Was the group deleted by the request ? (if no players remains or leader leaves)
     * @type {boolean}
     * @memberof GroupLeaveResult
     */
    deleted: boolean;
}
/**
 * 
 * @export
 * @interface GroupUpdateResult
 */
export interface GroupUpdateResult {
    /**
     * Updated group object
     * @type {Group}
     * @memberof GroupUpdateResult
     */
    group: Group;
    /**
     * Was the group updated by the request ?
     * @type {boolean}
     * @memberof GroupUpdateResult
     */
    updated: boolean;
}
/**
 * 
 * @export
 * @interface InternalStats
 */
export interface InternalStats {
    /**
     * 
     * @type {SessionStats}
     * @memberof InternalStats
     */
    sessionStats: SessionStats;
}
/**
 * 
 * @export
 * @interface LeaderboardCount
 */
export interface LeaderboardCount {
    /**
     * 
     * @type {number}
     * @memberof LeaderboardCount
     */
    recordsCount: number;
}
/**
 * 
 * @export
 * @interface LeaderboardDelete
 */
export interface LeaderboardDelete {
    /**
     * 
     * @type {boolean}
     * @memberof LeaderboardDelete
     */
    deleted: boolean;
}
/**
 * 
 * @export
 * @interface LeaderboardRangeEntry
 */
export interface LeaderboardRangeEntry {
    /**
     * 
     * @type {string}
     * @memberof LeaderboardRangeEntry
     */
    key: string;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardRangeEntry
     */
    score: number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardRangeEntry
     */
    rank: number;
}
/**
 * 
 * @export
 * @interface LeaderboardRecord
 */
export interface LeaderboardRecord {
    /**
     * Indicates if the leaderboard contains the requested record
     * @type {boolean}
     * @memberof LeaderboardRecord
     */
    exist: boolean;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardRecord
     */
    score: number;
    /**
     * Rank occupied by this record, starting at 0
     * @type {number}
     * @memberof LeaderboardRecord
     */
    rank: number;
}
/**
 * 
 * @export
 * @interface LoginPlayerDto
 */
export interface LoginPlayerDto {
    /**
     * 
     * @type {string}
     * @memberof LoginPlayerDto
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof LoginPlayerDto
     */
    password: string;
}
/**
 * 
 * @export
 * @interface Player
 */
export interface Player {
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    appId: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    displayName: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    birthDate: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    avatarUrl: string;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    isVerified: boolean;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    updatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    stripeCustomerId: string;
}
/**
 * 
 * @export
 * @interface PlayerLogin
 */
export interface PlayerLogin {
    /**
     * 
     * @type {string}
     * @memberof PlayerLogin
     */
    token: string;
    /**
     * 
     * @type {Player}
     * @memberof PlayerLogin
     */
    player: Player;
}
/**
 * 
 * @export
 * @interface PlayerRegisterResult
 */
export interface PlayerRegisterResult {
    /**
     * 
     * @type {boolean}
     * @memberof PlayerRegisterResult
     */
    success: boolean;
    /**
     * 
     * @type {Player}
     * @memberof PlayerRegisterResult
     */
    player: Player;
}
/**
 * 
 * @export
 * @interface Profile
 */
export interface Profile {
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    appId: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    owner: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    displayName: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    avatarUrl: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    updatedAt: string;
    /**
     * 
     * @type {Currencies}
     * @memberof Profile
     */
    currencies: Currencies;
}
/**
 * 
 * @export
 * @interface ProfileDelete
 */
export interface ProfileDelete {
    /**
     * 
     * @type {boolean}
     * @memberof ProfileDelete
     */
    deleted: boolean;
}
/**
 * 
 * @export
 * @interface ProfileUse
 */
export interface ProfileUse {
    /**
     * 
     * @type {string}
     * @memberof ProfileUse
     */
    token: string;
    /**
     * 
     * @type {Profile}
     * @memberof ProfileUse
     */
    profile: Profile;
}
/**
 * 
 * @export
 * @interface PurchaseShopDto
 */
export interface PurchaseShopDto {
    /**
     * 
     * @type {Array<ShopItemRefDto>}
     * @memberof PurchaseShopDto
     */
    items: Array<ShopItemRefDto>;
}
/**
 * 
 * @export
 * @interface RegisterPlayerDto
 */
export interface RegisterPlayerDto {
    /**
     * 
     * @type {string}
     * @memberof RegisterPlayerDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterPlayerDto
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterPlayerDto
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterPlayerDto
     */
    displayName: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterPlayerDto
     */
    birthDate: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterPlayerDto
     */
    avatarUrl: string;
}
/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    start: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    end: string;
}
/**
 * 
 * @export
 * @interface SessionStats
 */
export interface SessionStats {
    /**
     * 
     * @type {string}
     * @memberof SessionStats
     */
    lastSession: string;
    /**
     * 
     * @type {number}
     * @memberof SessionStats
     */
    minSessionDuration: number;
    /**
     * 
     * @type {number}
     * @memberof SessionStats
     */
    maxSessionDuration: number;
    /**
     * 
     * @type {number}
     * @memberof SessionStats
     */
    sessionsCount: number;
    /**
     * 
     * @type {number}
     * @memberof SessionStats
     */
    totalDuration: number;
    /**
     * 
     * @type {Array<Session>}
     * @memberof SessionStats
     */
    sessions: Array<Session>;
}
/**
 * 
 * @export
 * @interface SetGroupDataDto
 */
export interface SetGroupDataDto {
    /**
     * 
     * @type {object}
     * @memberof SetGroupDataDto
     */
    publicData: object;
    /**
     * 
     * @type {object}
     * @memberof SetGroupDataDto
     */
    privateData: object;
}
/**
 * 
 * @export
 * @interface SetLeaderboardRecordDto
 */
export interface SetLeaderboardRecordDto {
    /**
     * 
     * @type {string}
     * @memberof SetLeaderboardRecordDto
     */
    leaderboard: string;
    /**
     * 
     * @type {number}
     * @memberof SetLeaderboardRecordDto
     */
    value: number;
}
/**
 * 
 * @export
 * @interface Shop
 */
export interface Shop {
    /**
     * 
     * @type {string}
     * @memberof Shop
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Shop
     */
    appId: string;
    /**
     * 
     * @type {string}
     * @memberof Shop
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Shop
     */
    displayName: string;
    /**
     * 
     * @type {string}
     * @memberof Shop
     */
    description: string;
    /**
     * 
     * @type {boolean}
     * @memberof Shop
     */
    published: boolean;
    /**
     * 
     * @type {string}
     * @memberof Shop
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof Shop
     */
    updatedAt: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Shop
     */
    categories: Array<string>;
}
/**
 * 
 * @export
 * @interface ShopCurrencyValueDto
 */
export interface ShopCurrencyValueDto {
    /**
     * 
     * @type {string}
     * @memberof ShopCurrencyValueDto
     */
    currency: string;
    /**
     * 
     * @type {number}
     * @memberof ShopCurrencyValueDto
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof ShopCurrencyValueDto
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ShopItemDto
 */
export interface ShopItemDto {
    /**
     * 
     * @type {object}
     * @memberof ShopItemDto
     */
    data: object;
    /**
     * 
     * @type {Array<ShopCurrencyValueDto>}
     * @memberof ShopItemDto
     */
    costs: Array<ShopCurrencyValueDto>;
    /**
     * 
     * @type {object}
     * @memberof ShopItemDto
     */
    grantType: object;
}
/**
 * 
 * @export
 * @interface ShopItemRefDto
 */
export interface ShopItemRefDto {
    /**
     * 
     * @type {string}
     * @memberof ShopItemRefDto
     */
    shopId: string;
    /**
     * 
     * @type {string}
     * @memberof ShopItemRefDto
     */
    categoryId: string;
    /**
     * 
     * @type {number}
     * @memberof ShopItemRefDto
     */
    itemIndex: number;
    /**
     * 
     * @type {number}
     * @memberof ShopItemRefDto
     */
    quantity: number;
    /**
     * 
     * @type {string}
     * @memberof ShopItemRefDto
     */
    grantTo: string;
}
/**
 * 
 * @export
 * @interface StatObject
 */
export interface StatObject {
    /**
     * 
     * @type {string}
     * @memberof StatObject
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof StatObject
     */
    value: number;
    /**
     * 
     * @type {boolean}
     * @memberof StatObject
     */
    isIncrement: boolean;
}
/**
 * 
 * @export
 * @interface Stats
 */
export interface Stats {
    /**
     * Publicly-accessibles stats (can be seen by everyone)
     * @type {{ [key: string]: number; }}
     * @memberof Stats
     */
    publicStats: { [key: string]: number; };
    /**
     * Private stats (can be seen only by the owner)
     * @type {{ [key: string]: number; }}
     * @memberof Stats
     */
    privateStats: { [key: string]: number; };
    /**
     * Internal stats used by indiebackend (such as sessionStats, etc.)
     * @type {InternalStats}
     * @memberof Stats
     */
    internalStats: InternalStats;
}
/**
 * 
 * @export
 * @interface UpdateStatsDto
 */
export interface UpdateStatsDto {
    /**
     * 
     * @type {Array<StatObject>}
     * @memberof UpdateStatsDto
     */
    publicStats: Array<StatObject>;
    /**
     * 
     * @type {Array<StatObject>}
     * @memberof UpdateStatsDto
     */
    privateStats: Array<StatObject>;
}

/**
 * CurrenciesApi - axios parameter creator
 * @export
 */
export const CurrenciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return all currencies for a profile
         * @summary Return all currencies for a profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencies: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/currencies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set public and private currencies for a profile. Note: Internal currencies can only be set by an Indiebackend Service
         * @summary Set currencies for a profile
         * @param {CurrenciesDto} currenciesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCurrencies: async (currenciesDto: CurrenciesDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'currenciesDto' is not null or undefined
            assertParamExists('setCurrencies', 'currenciesDto', currenciesDto)
            const localVarPath = `/currencies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(currenciesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update public and private currencies for a profile. Note: Internal currencies can only be updated by an Indiebackend Service
         * @summary Update currencies for a profile
         * @param {CurrenciesDto} currenciesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrencies: async (currenciesDto: CurrenciesDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'currenciesDto' is not null or undefined
            assertParamExists('updateCurrencies', 'currenciesDto', currenciesDto)
            const localVarPath = `/currencies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(currenciesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrenciesApi - functional programming interface
 * @export
 */
export const CurrenciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CurrenciesApiAxiosParamCreator(configuration)
    return {
        /**
         * Return all currencies for a profile
         * @summary Return all currencies for a profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrencies(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Currencies>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrencies(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set public and private currencies for a profile. Note: Internal currencies can only be set by an Indiebackend Service
         * @summary Set currencies for a profile
         * @param {CurrenciesDto} currenciesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setCurrencies(currenciesDto: CurrenciesDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Currencies>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCurrencies(currenciesDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update public and private currencies for a profile. Note: Internal currencies can only be updated by an Indiebackend Service
         * @summary Update currencies for a profile
         * @param {CurrenciesDto} currenciesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCurrencies(currenciesDto: CurrenciesDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Currencies>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCurrencies(currenciesDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CurrenciesApi - factory interface
 * @export
 */
export const CurrenciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CurrenciesApiFp(configuration)
    return {
        /**
         * Return all currencies for a profile
         * @summary Return all currencies for a profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencies(options?: any): AxiosPromise<Currencies> {
            return localVarFp.getCurrencies(options).then((request) => request(axios, basePath));
        },
        /**
         * Set public and private currencies for a profile. Note: Internal currencies can only be set by an Indiebackend Service
         * @summary Set currencies for a profile
         * @param {CurrenciesDto} currenciesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCurrencies(currenciesDto: CurrenciesDto, options?: any): AxiosPromise<Currencies> {
            return localVarFp.setCurrencies(currenciesDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update public and private currencies for a profile. Note: Internal currencies can only be updated by an Indiebackend Service
         * @summary Update currencies for a profile
         * @param {CurrenciesDto} currenciesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrencies(currenciesDto: CurrenciesDto, options?: any): AxiosPromise<Currencies> {
            return localVarFp.updateCurrencies(currenciesDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CurrenciesApi - object-oriented interface
 * @export
 * @class CurrenciesApi
 * @extends {BaseAPI}
 */
export class CurrenciesApi extends BaseAPI {
    /**
     * Return all currencies for a profile
     * @summary Return all currencies for a profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public getCurrencies(options?: any) {
        return CurrenciesApiFp(this.configuration).getCurrencies(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set public and private currencies for a profile. Note: Internal currencies can only be set by an Indiebackend Service
     * @summary Set currencies for a profile
     * @param {CurrenciesDto} currenciesDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public setCurrencies(currenciesDto: CurrenciesDto, options?: any) {
        return CurrenciesApiFp(this.configuration).setCurrencies(currenciesDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update public and private currencies for a profile. Note: Internal currencies can only be updated by an Indiebackend Service
     * @summary Update currencies for a profile
     * @param {CurrenciesDto} currenciesDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public updateCurrencies(currenciesDto: CurrenciesDto, options?: any) {
        return CurrenciesApiFp(this.configuration).updateCurrencies(currenciesDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new group based on the given informations, send an In-App notification to every members on their profile\'s channel (Notification is WIP)
         * @summary Create group
         * @param {CreateGroupDto} createGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (createGroupDto: CreateGroupDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGroupDto' is not null or undefined
            assertParamExists('createGroup', 'createGroupDto', createGroupDto)
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGroupDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a group from the database, sends a notification that the group has been deleted on the group\'s channel
         * @summary Delete a group
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGroup', 'id', id)
            const localVarPath = `/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get group\'s data such as members, private & public data, etc...
         * @summary Get a group
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGroup', 'id', id)
            const localVarPath = `/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allow a profile to join a group, sends a notification that the profile has joined on the group\'s channel
         * @summary Join a group
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinGroup: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('joinGroup', 'id', id)
            const localVarPath = `/groups/{id}/join`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a profile from group\'s members. Sends a notification that the profile has left on the group\'s channel
         * @summary Leave a group
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveGroup: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('leaveGroup', 'id', id)
            const localVarPath = `/groups/{id}/leave`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set a group\'s public and private data. Sends a notification that the group\'s datas has been updated on the group\'s channel
         * @summary Set group\'s data
         * @param {string} id 
         * @param {SetGroupDataDto} setGroupDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGroupData: async (id: string, setGroupDataDto: SetGroupDataDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setGroupData', 'id', id)
            // verify required parameter 'setGroupDataDto' is not null or undefined
            assertParamExists('setGroupData', 'setGroupDataDto', setGroupDataDto)
            const localVarPath = `/groups/{id}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setGroupDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Makes a profile the group leader. Only the current group\'s leader can perform this operation. Sends a notification that a new leader has been set on the group\'s channel
         * @summary Set group leader
         * @param {string} id 
         * @param {string} leader 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGroupLeader: async (id: string, leader: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setGroupLeader', 'id', id)
            // verify required parameter 'leader' is not null or undefined
            assertParamExists('setGroupLeader', 'leader', leader)
            const localVarPath = `/groups/{id}/leader`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (leader !== undefined) {
                localVarQueryParameter['leader'] = leader;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new group based on the given informations, send an In-App notification to every members on their profile\'s channel (Notification is WIP)
         * @summary Create group
         * @param {CreateGroupDto} createGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(createGroupDto: CreateGroupDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(createGroupDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a group from the database, sends a notification that the group has been deleted on the group\'s channel
         * @summary Delete a group
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupDeletedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get group\'s data such as members, private & public data, etc...
         * @summary Get a group
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroup(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allow a profile to join a group, sends a notification that the profile has joined on the group\'s channel
         * @summary Join a group
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinGroup(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupUpdateResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.joinGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a profile from group\'s members. Sends a notification that the profile has left on the group\'s channel
         * @summary Leave a group
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveGroup(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupLeaveResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set a group\'s public and private data. Sends a notification that the group\'s datas has been updated on the group\'s channel
         * @summary Set group\'s data
         * @param {string} id 
         * @param {SetGroupDataDto} setGroupDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setGroupData(id: string, setGroupDataDto: SetGroupDataDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupUpdateResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setGroupData(id, setGroupDataDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Makes a profile the group leader. Only the current group\'s leader can perform this operation. Sends a notification that a new leader has been set on the group\'s channel
         * @summary Set group leader
         * @param {string} id 
         * @param {string} leader 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setGroupLeader(id: string, leader: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupUpdateResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setGroupLeader(id, leader, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * Create a new group based on the given informations, send an In-App notification to every members on their profile\'s channel (Notification is WIP)
         * @summary Create group
         * @param {CreateGroupDto} createGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(createGroupDto: CreateGroupDto, options?: any): AxiosPromise<Group> {
            return localVarFp.createGroup(createGroupDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a group from the database, sends a notification that the group has been deleted on the group\'s channel
         * @summary Delete a group
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(id: string, options?: any): AxiosPromise<GroupDeletedDto> {
            return localVarFp.deleteGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get group\'s data such as members, private & public data, etc...
         * @summary Get a group
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(id: string, options?: any): AxiosPromise<Group> {
            return localVarFp.getGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Allow a profile to join a group, sends a notification that the profile has joined on the group\'s channel
         * @summary Join a group
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinGroup(id: string, options?: any): AxiosPromise<GroupUpdateResult> {
            return localVarFp.joinGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a profile from group\'s members. Sends a notification that the profile has left on the group\'s channel
         * @summary Leave a group
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveGroup(id: string, options?: any): AxiosPromise<GroupLeaveResult> {
            return localVarFp.leaveGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Set a group\'s public and private data. Sends a notification that the group\'s datas has been updated on the group\'s channel
         * @summary Set group\'s data
         * @param {string} id 
         * @param {SetGroupDataDto} setGroupDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGroupData(id: string, setGroupDataDto: SetGroupDataDto, options?: any): AxiosPromise<GroupUpdateResult> {
            return localVarFp.setGroupData(id, setGroupDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Makes a profile the group leader. Only the current group\'s leader can perform this operation. Sends a notification that a new leader has been set on the group\'s channel
         * @summary Set group leader
         * @param {string} id 
         * @param {string} leader 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGroupLeader(id: string, leader: string, options?: any): AxiosPromise<GroupUpdateResult> {
            return localVarFp.setGroupLeader(id, leader, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * Create a new group based on the given informations, send an In-App notification to every members on their profile\'s channel (Notification is WIP)
     * @summary Create group
     * @param {CreateGroupDto} createGroupDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public createGroup(createGroupDto: CreateGroupDto, options?: any) {
        return GroupsApiFp(this.configuration).createGroup(createGroupDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a group from the database, sends a notification that the group has been deleted on the group\'s channel
     * @summary Delete a group
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteGroup(id: string, options?: any) {
        return GroupsApiFp(this.configuration).deleteGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get group\'s data such as members, private & public data, etc...
     * @summary Get a group
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroup(id: string, options?: any) {
        return GroupsApiFp(this.configuration).getGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allow a profile to join a group, sends a notification that the profile has joined on the group\'s channel
     * @summary Join a group
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public joinGroup(id: string, options?: any) {
        return GroupsApiFp(this.configuration).joinGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a profile from group\'s members. Sends a notification that the profile has left on the group\'s channel
     * @summary Leave a group
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public leaveGroup(id: string, options?: any) {
        return GroupsApiFp(this.configuration).leaveGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set a group\'s public and private data. Sends a notification that the group\'s datas has been updated on the group\'s channel
     * @summary Set group\'s data
     * @param {string} id 
     * @param {SetGroupDataDto} setGroupDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public setGroupData(id: string, setGroupDataDto: SetGroupDataDto, options?: any) {
        return GroupsApiFp(this.configuration).setGroupData(id, setGroupDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Makes a profile the group leader. Only the current group\'s leader can perform this operation. Sends a notification that a new leader has been set on the group\'s channel
     * @summary Set group leader
     * @param {string} id 
     * @param {string} leader 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public setGroupLeader(id: string, leader: string, options?: any) {
        return GroupsApiFp(this.configuration).setGroupLeader(id, leader, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LeaderboardsApi - axios parameter creator
 * @export
 */
export const LeaderboardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Clear leaderboard of all record
         * @summary Clear leaderboard of all record
         * @param {string} leaderboard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearLeaderboard: async (leaderboard: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'leaderboard' is not null or undefined
            assertParamExists('clearLeaderboard', 'leaderboard', leaderboard)
            const localVarPath = `/leaderboards/{leaderboard}`
                .replace(`{${"leaderboard"}}`, encodeURIComponent(String(leaderboard)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a record from the leaderboard
         * @summary Delete a record from the leaderboard
         * @param {string} leaderboard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecord: async (leaderboard: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'leaderboard' is not null or undefined
            assertParamExists('deleteRecord', 'leaderboard', leaderboard)
            const localVarPath = `/leaderboards/{leaderboard}/record`
                .replace(`{${"leaderboard"}}`, encodeURIComponent(String(leaderboard)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the number of records in the leaderboard
         * @summary Return the number of records in the leaderboard
         * @param {string} leaderboard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCount: async (leaderboard: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'leaderboard' is not null or undefined
            assertParamExists('getCount', 'leaderboard', leaderboard)
            const localVarPath = `/leaderboards/{leaderboard}/count`
                .replace(`{${"leaderboard"}}`, encodeURIComponent(String(leaderboard)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a range of players based on their ranks or their scores.
         * @summary Get a range of players
         * @param {string} leaderboard 
         * @param {string} queryMode 
         * @param {number} from 
         * @param {number} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRange: async (leaderboard: string, queryMode: string, from: number, to: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'leaderboard' is not null or undefined
            assertParamExists('getRange', 'leaderboard', leaderboard)
            // verify required parameter 'queryMode' is not null or undefined
            assertParamExists('getRange', 'queryMode', queryMode)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getRange', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getRange', 'to', to)
            const localVarPath = `/leaderboards/{leaderboard}/range`
                .replace(`{${"leaderboard"}}`, encodeURIComponent(String(leaderboard)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (queryMode !== undefined) {
                localVarQueryParameter['queryMode'] = queryMode;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a record from the leaderboard
         * @summary Get a record from the leaderboard
         * @param {string} leaderboard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecord: async (leaderboard: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'leaderboard' is not null or undefined
            assertParamExists('getRecord', 'leaderboard', leaderboard)
            const localVarPath = `/leaderboards/{leaderboard}`
                .replace(`{${"leaderboard"}}`, encodeURIComponent(String(leaderboard)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Increment a record\'s score in a leaderboard by a specified amount
         * @summary Increment a record\'s score in a leaderboard by a specified amount
         * @param {SetLeaderboardRecordDto} setLeaderboardRecordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incrementRecord: async (setLeaderboardRecordDto: SetLeaderboardRecordDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'setLeaderboardRecordDto' is not null or undefined
            assertParamExists('incrementRecord', 'setLeaderboardRecordDto', setLeaderboardRecordDto)
            const localVarPath = `/leaderboards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setLeaderboardRecordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set a record in a leaderboard
         * @summary Set a record in a leaderboard
         * @param {SetLeaderboardRecordDto} setLeaderboardRecordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRecord: async (setLeaderboardRecordDto: SetLeaderboardRecordDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'setLeaderboardRecordDto' is not null or undefined
            assertParamExists('setRecord', 'setLeaderboardRecordDto', setLeaderboardRecordDto)
            const localVarPath = `/leaderboards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setLeaderboardRecordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeaderboardsApi - functional programming interface
 * @export
 */
export const LeaderboardsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LeaderboardsApiAxiosParamCreator(configuration)
    return {
        /**
         * Clear leaderboard of all record
         * @summary Clear leaderboard of all record
         * @param {string} leaderboard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearLeaderboard(leaderboard: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeaderboardDelete>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearLeaderboard(leaderboard, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a record from the leaderboard
         * @summary Delete a record from the leaderboard
         * @param {string} leaderboard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecord(leaderboard: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeaderboardDelete>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecord(leaderboard, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return the number of records in the leaderboard
         * @summary Return the number of records in the leaderboard
         * @param {string} leaderboard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCount(leaderboard: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeaderboardCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCount(leaderboard, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a range of players based on their ranks or their scores.
         * @summary Get a range of players
         * @param {string} leaderboard 
         * @param {string} queryMode 
         * @param {number} from 
         * @param {number} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRange(leaderboard: string, queryMode: string, from: number, to: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LeaderboardRangeEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRange(leaderboard, queryMode, from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a record from the leaderboard
         * @summary Get a record from the leaderboard
         * @param {string} leaderboard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecord(leaderboard: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeaderboardRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecord(leaderboard, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Increment a record\'s score in a leaderboard by a specified amount
         * @summary Increment a record\'s score in a leaderboard by a specified amount
         * @param {SetLeaderboardRecordDto} setLeaderboardRecordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async incrementRecord(setLeaderboardRecordDto: SetLeaderboardRecordDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeaderboardRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.incrementRecord(setLeaderboardRecordDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set a record in a leaderboard
         * @summary Set a record in a leaderboard
         * @param {SetLeaderboardRecordDto} setLeaderboardRecordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRecord(setLeaderboardRecordDto: SetLeaderboardRecordDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeaderboardRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRecord(setLeaderboardRecordDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LeaderboardsApi - factory interface
 * @export
 */
export const LeaderboardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LeaderboardsApiFp(configuration)
    return {
        /**
         * Clear leaderboard of all record
         * @summary Clear leaderboard of all record
         * @param {string} leaderboard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearLeaderboard(leaderboard: string, options?: any): AxiosPromise<LeaderboardDelete> {
            return localVarFp.clearLeaderboard(leaderboard, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a record from the leaderboard
         * @summary Delete a record from the leaderboard
         * @param {string} leaderboard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecord(leaderboard: string, options?: any): AxiosPromise<LeaderboardDelete> {
            return localVarFp.deleteRecord(leaderboard, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the number of records in the leaderboard
         * @summary Return the number of records in the leaderboard
         * @param {string} leaderboard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCount(leaderboard: string, options?: any): AxiosPromise<LeaderboardCount> {
            return localVarFp.getCount(leaderboard, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a range of players based on their ranks or their scores.
         * @summary Get a range of players
         * @param {string} leaderboard 
         * @param {string} queryMode 
         * @param {number} from 
         * @param {number} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRange(leaderboard: string, queryMode: string, from: number, to: number, options?: any): AxiosPromise<Array<LeaderboardRangeEntry>> {
            return localVarFp.getRange(leaderboard, queryMode, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a record from the leaderboard
         * @summary Get a record from the leaderboard
         * @param {string} leaderboard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecord(leaderboard: string, options?: any): AxiosPromise<LeaderboardRecord> {
            return localVarFp.getRecord(leaderboard, options).then((request) => request(axios, basePath));
        },
        /**
         * Increment a record\'s score in a leaderboard by a specified amount
         * @summary Increment a record\'s score in a leaderboard by a specified amount
         * @param {SetLeaderboardRecordDto} setLeaderboardRecordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incrementRecord(setLeaderboardRecordDto: SetLeaderboardRecordDto, options?: any): AxiosPromise<LeaderboardRecord> {
            return localVarFp.incrementRecord(setLeaderboardRecordDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Set a record in a leaderboard
         * @summary Set a record in a leaderboard
         * @param {SetLeaderboardRecordDto} setLeaderboardRecordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRecord(setLeaderboardRecordDto: SetLeaderboardRecordDto, options?: any): AxiosPromise<LeaderboardRecord> {
            return localVarFp.setRecord(setLeaderboardRecordDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LeaderboardsApi - object-oriented interface
 * @export
 * @class LeaderboardsApi
 * @extends {BaseAPI}
 */
export class LeaderboardsApi extends BaseAPI {
    /**
     * Clear leaderboard of all record
     * @summary Clear leaderboard of all record
     * @param {string} leaderboard 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardsApi
     */
    public clearLeaderboard(leaderboard: string, options?: any) {
        return LeaderboardsApiFp(this.configuration).clearLeaderboard(leaderboard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a record from the leaderboard
     * @summary Delete a record from the leaderboard
     * @param {string} leaderboard 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardsApi
     */
    public deleteRecord(leaderboard: string, options?: any) {
        return LeaderboardsApiFp(this.configuration).deleteRecord(leaderboard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the number of records in the leaderboard
     * @summary Return the number of records in the leaderboard
     * @param {string} leaderboard 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardsApi
     */
    public getCount(leaderboard: string, options?: any) {
        return LeaderboardsApiFp(this.configuration).getCount(leaderboard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a range of players based on their ranks or their scores.
     * @summary Get a range of players
     * @param {string} leaderboard 
     * @param {string} queryMode 
     * @param {number} from 
     * @param {number} to 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardsApi
     */
    public getRange(leaderboard: string, queryMode: string, from: number, to: number, options?: any) {
        return LeaderboardsApiFp(this.configuration).getRange(leaderboard, queryMode, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a record from the leaderboard
     * @summary Get a record from the leaderboard
     * @param {string} leaderboard 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardsApi
     */
    public getRecord(leaderboard: string, options?: any) {
        return LeaderboardsApiFp(this.configuration).getRecord(leaderboard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Increment a record\'s score in a leaderboard by a specified amount
     * @summary Increment a record\'s score in a leaderboard by a specified amount
     * @param {SetLeaderboardRecordDto} setLeaderboardRecordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardsApi
     */
    public incrementRecord(setLeaderboardRecordDto: SetLeaderboardRecordDto, options?: any) {
        return LeaderboardsApiFp(this.configuration).incrementRecord(setLeaderboardRecordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set a record in a leaderboard
     * @summary Set a record in a leaderboard
     * @param {SetLeaderboardRecordDto} setLeaderboardRecordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardsApi
     */
    public setRecord(setLeaderboardRecordDto: SetLeaderboardRecordDto, options?: any) {
        return LeaderboardsApiFp(this.configuration).setRecord(setLeaderboardRecordDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint generates a checkout session and then redirects the client (if redirect is set to true in the request, returns the checkout link\'s otherwise). Note: This endpoint is not yet secured, as everyone can set what to buy, this feature will later be restricted to Admin SDk
         * @summary Initialize the payment process, using provided informations
         * @param {boolean} redirect 
         * @param {CreateCheckoutDto} createCheckoutDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckout: async (redirect: boolean, createCheckoutDto: CreateCheckoutDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'redirect' is not null or undefined
            assertParamExists('createCheckout', 'redirect', redirect)
            // verify required parameter 'createCheckoutDto' is not null or undefined
            assertParamExists('createCheckout', 'createCheckoutDto', createCheckoutDto)
            const localVarPath = `/payments/checkout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCheckoutDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint generates a checkout session and then redirects the client (if redirect is set to true in the request, returns the checkout link\'s otherwise). Note: This endpoint is not yet secured, as everyone can set what to buy, this feature will later be restricted to Admin SDk
         * @summary Initialize the payment process, using provided informations
         * @param {boolean} redirect 
         * @param {CreateCheckoutDto} createCheckoutDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheckout(redirect: boolean, createCheckoutDto: CreateCheckoutDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutSessionCreated>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheckout(redirect, createCheckoutDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentsApiFp(configuration)
    return {
        /**
         * This endpoint generates a checkout session and then redirects the client (if redirect is set to true in the request, returns the checkout link\'s otherwise). Note: This endpoint is not yet secured, as everyone can set what to buy, this feature will later be restricted to Admin SDk
         * @summary Initialize the payment process, using provided informations
         * @param {boolean} redirect 
         * @param {CreateCheckoutDto} createCheckoutDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckout(redirect: boolean, createCheckoutDto: CreateCheckoutDto, options?: any): AxiosPromise<CheckoutSessionCreated> {
            return localVarFp.createCheckout(redirect, createCheckoutDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
    /**
     * This endpoint generates a checkout session and then redirects the client (if redirect is set to true in the request, returns the checkout link\'s otherwise). Note: This endpoint is not yet secured, as everyone can set what to buy, this feature will later be restricted to Admin SDk
     * @summary Initialize the payment process, using provided informations
     * @param {boolean} redirect 
     * @param {CreateCheckoutDto} createCheckoutDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public createCheckout(redirect: boolean, createCheckoutDto: CreateCheckoutDto, options?: any) {
        return PaymentsApiFp(this.configuration).createCheckout(redirect, createCheckoutDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlayersApi - axios parameter creator
 * @export
 */
export const PlayersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return a player\'s general informations
         * @summary Get player\'s profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayer: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/players`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login a player to an application using an email and password
         * @summary Login player via email and password
         * @param {string} appId Application Id to use
         * @param {LoginPlayerDto} loginPlayerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginPlayerEmail: async (appId: string, loginPlayerDto: LoginPlayerDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('loginPlayerEmail', 'appId', appId)
            // verify required parameter 'loginPlayerDto' is not null or undefined
            assertParamExists('loginPlayerEmail', 'loginPlayerDto', loginPlayerDto)
            const localVarPath = `/players/login/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (appId !== undefined && appId !== null) {
                localVarHeaderParameter['AppId'] = String(appId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginPlayerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redirect a client to the OAuth2 dialog of a supported OAuth2 provider
         * @summary OAuth2 redirection to a supported provider
         * @param {string} provider 
         * @param {string} appId Application Id to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectOauth: async (provider: string, appId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('redirectOauth', 'provider', provider)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('redirectOauth', 'appId', appId)
            const localVarPath = `/players/redirect/{provider}`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (appId !== undefined && appId !== null) {
                localVarHeaderParameter['AppId'] = String(appId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a new account for an application using an email and password
         * @summary Register player via email and password
         * @param {string} appId Application Id to use
         * @param {RegisterPlayerDto} registerPlayerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPlayerEmail: async (appId: string, registerPlayerDto: RegisterPlayerDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('registerPlayerEmail', 'appId', appId)
            // verify required parameter 'registerPlayerDto' is not null or undefined
            assertParamExists('registerPlayerEmail', 'registerPlayerDto', registerPlayerDto)
            const localVarPath = `/players/register/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (appId !== undefined && appId !== null) {
                localVarHeaderParameter['AppId'] = String(appId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerPlayerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayersApi - functional programming interface
 * @export
 */
export const PlayersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlayersApiAxiosParamCreator(configuration)
    return {
        /**
         * Return a player\'s general informations
         * @summary Get player\'s profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayer(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Player>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayer(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Login a player to an application using an email and password
         * @summary Login player via email and password
         * @param {string} appId Application Id to use
         * @param {LoginPlayerDto} loginPlayerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginPlayerEmail(appId: string, loginPlayerDto: LoginPlayerDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginPlayerEmail(appId, loginPlayerDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Redirect a client to the OAuth2 dialog of a supported OAuth2 provider
         * @summary OAuth2 redirection to a supported provider
         * @param {string} provider 
         * @param {string} appId Application Id to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redirectOauth(provider: string, appId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redirectOauth(provider, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register a new account for an application using an email and password
         * @summary Register player via email and password
         * @param {string} appId Application Id to use
         * @param {RegisterPlayerDto} registerPlayerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerPlayerEmail(appId: string, registerPlayerDto: RegisterPlayerDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerRegisterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerPlayerEmail(appId, registerPlayerDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlayersApi - factory interface
 * @export
 */
export const PlayersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlayersApiFp(configuration)
    return {
        /**
         * Return a player\'s general informations
         * @summary Get player\'s profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayer(options?: any): AxiosPromise<Player> {
            return localVarFp.getPlayer(options).then((request) => request(axios, basePath));
        },
        /**
         * Login a player to an application using an email and password
         * @summary Login player via email and password
         * @param {string} appId Application Id to use
         * @param {LoginPlayerDto} loginPlayerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginPlayerEmail(appId: string, loginPlayerDto: LoginPlayerDto, options?: any): AxiosPromise<PlayerLogin> {
            return localVarFp.loginPlayerEmail(appId, loginPlayerDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Redirect a client to the OAuth2 dialog of a supported OAuth2 provider
         * @summary OAuth2 redirection to a supported provider
         * @param {string} provider 
         * @param {string} appId Application Id to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectOauth(provider: string, appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.redirectOauth(provider, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a new account for an application using an email and password
         * @summary Register player via email and password
         * @param {string} appId Application Id to use
         * @param {RegisterPlayerDto} registerPlayerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPlayerEmail(appId: string, registerPlayerDto: RegisterPlayerDto, options?: any): AxiosPromise<PlayerRegisterResult> {
            return localVarFp.registerPlayerEmail(appId, registerPlayerDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlayersApi - object-oriented interface
 * @export
 * @class PlayersApi
 * @extends {BaseAPI}
 */
export class PlayersApi extends BaseAPI {
    /**
     * Return a player\'s general informations
     * @summary Get player\'s profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public getPlayer(options?: any) {
        return PlayersApiFp(this.configuration).getPlayer(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Login a player to an application using an email and password
     * @summary Login player via email and password
     * @param {string} appId Application Id to use
     * @param {LoginPlayerDto} loginPlayerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public loginPlayerEmail(appId: string, loginPlayerDto: LoginPlayerDto, options?: any) {
        return PlayersApiFp(this.configuration).loginPlayerEmail(appId, loginPlayerDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Redirect a client to the OAuth2 dialog of a supported OAuth2 provider
     * @summary OAuth2 redirection to a supported provider
     * @param {string} provider 
     * @param {string} appId Application Id to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public redirectOauth(provider: string, appId: string, options?: any) {
        return PlayersApiFp(this.configuration).redirectOauth(provider, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a new account for an application using an email and password
     * @summary Register player via email and password
     * @param {string} appId Application Id to use
     * @param {RegisterPlayerDto} registerPlayerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public registerPlayerEmail(appId: string, registerPlayerDto: RegisterPlayerDto, options?: any) {
        return PlayersApiFp(this.configuration).registerPlayerEmail(appId, registerPlayerDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProfilesApi - axios parameter creator
 * @export
 */
export const ProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new profile linked to player\'s account
         * @summary Create a new profile linked to player\'s account
         * @param {CreateProfileDto} createProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile: async (createProfileDto: CreateProfileDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProfileDto' is not null or undefined
            assertParamExists('createProfile', 'createProfileDto', createProfileDto)
            const localVarPath = `/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProfileDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the profile
         * @summary Delete profile
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProfile', 'id', id)
            const localVarPath = `/profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return current profile\'s data
         * @summary Get profile
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProfile', 'id', id)
            const localVarPath = `/profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all profiles owned by the current player
         * @summary List profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProfiles: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a profile token used by all services and current profile\'s data
         * @summary Use a profile
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        useProfile: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('useProfile', 'id', id)
            const localVarPath = `/profiles/use`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfilesApi - functional programming interface
 * @export
 */
export const ProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new profile linked to player\'s account
         * @summary Create a new profile linked to player\'s account
         * @param {CreateProfileDto} createProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProfile(createProfileDto: CreateProfileDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProfile(createProfileDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the profile
         * @summary Delete profile
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProfile(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileDelete>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProfile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return current profile\'s data
         * @summary Get profile
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfile(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all profiles owned by the current player
         * @summary List profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProfiles(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Profile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProfiles(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a profile token used by all services and current profile\'s data
         * @summary Use a profile
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async useProfile(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileUse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.useProfile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProfilesApi - factory interface
 * @export
 */
export const ProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfilesApiFp(configuration)
    return {
        /**
         * Create a new profile linked to player\'s account
         * @summary Create a new profile linked to player\'s account
         * @param {CreateProfileDto} createProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile(createProfileDto: CreateProfileDto, options?: any): AxiosPromise<Profile> {
            return localVarFp.createProfile(createProfileDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the profile
         * @summary Delete profile
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile(id: string, options?: any): AxiosPromise<ProfileDelete> {
            return localVarFp.deleteProfile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Return current profile\'s data
         * @summary Get profile
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(id: string, options?: any): AxiosPromise<Profile> {
            return localVarFp.getProfile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List all profiles owned by the current player
         * @summary List profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProfiles(options?: any): AxiosPromise<Array<Profile>> {
            return localVarFp.listProfiles(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a profile token used by all services and current profile\'s data
         * @summary Use a profile
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        useProfile(id: string, options?: any): AxiosPromise<ProfileUse> {
            return localVarFp.useProfile(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfilesApi - object-oriented interface
 * @export
 * @class ProfilesApi
 * @extends {BaseAPI}
 */
export class ProfilesApi extends BaseAPI {
    /**
     * Create a new profile linked to player\'s account
     * @summary Create a new profile linked to player\'s account
     * @param {CreateProfileDto} createProfileDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public createProfile(createProfileDto: CreateProfileDto, options?: any) {
        return ProfilesApiFp(this.configuration).createProfile(createProfileDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the profile
     * @summary Delete profile
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public deleteProfile(id: string, options?: any) {
        return ProfilesApiFp(this.configuration).deleteProfile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return current profile\'s data
     * @summary Get profile
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public getProfile(id: string, options?: any) {
        return ProfilesApiFp(this.configuration).getProfile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all profiles owned by the current player
     * @summary List profiles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public listProfiles(options?: any) {
        return ProfilesApiFp(this.configuration).listProfiles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a profile token used by all services and current profile\'s data
     * @summary Use a profile
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public useProfile(id: string, options?: any) {
        return ProfilesApiFp(this.configuration).useProfile(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShopsApi - axios parameter creator
 * @export
 */
export const ShopsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a category from a shop
         * @summary Get a category from a shop
         * @param {string} shopId 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory: async (shopId: string, categoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shopId' is not null or undefined
            assertParamExists('getCategory', 'shopId', shopId)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getCategory', 'categoryId', categoryId)
            const localVarPath = `/shops/{shopId}/{categoryId}`
                .replace(`{${"shopId"}}`, encodeURIComponent(String(shopId)))
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a shop
         * @summary Get shop
         * @param {string} shopId 
         * @param {boolean} withCategories 
         * @param {string} appId Application Id to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShop: async (shopId: string, withCategories: boolean, appId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shopId' is not null or undefined
            assertParamExists('getShop', 'shopId', shopId)
            // verify required parameter 'withCategories' is not null or undefined
            assertParamExists('getShop', 'withCategories', withCategories)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getShop', 'appId', appId)
            const localVarPath = `/shops/{shopId}`
                .replace(`{${"shopId"}}`, encodeURIComponent(String(shopId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (withCategories !== undefined) {
                localVarQueryParameter['withCategories'] = withCategories;
            }

            if (appId !== undefined && appId !== null) {
                localVarHeaderParameter['AppId'] = String(appId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make a purchase in one or more shops
         * @summary Make a purchase in one or more shops
         * @param {PurchaseShopDto} purchaseShopDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchase: async (purchaseShopDto: PurchaseShopDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'purchaseShopDto' is not null or undefined
            assertParamExists('purchase', 'purchaseShopDto', purchaseShopDto)
            const localVarPath = `/shops/purchase`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(purchaseShopDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShopsApi - functional programming interface
 * @export
 */
export const ShopsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShopsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a category from a shop
         * @summary Get a category from a shop
         * @param {string} shopId 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategory(shopId: string, categoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategory(shopId, categoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a shop
         * @summary Get shop
         * @param {string} shopId 
         * @param {boolean} withCategories 
         * @param {string} appId Application Id to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShop(shopId: string, withCategories: boolean, appId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shop>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShop(shopId, withCategories, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Make a purchase in one or more shops
         * @summary Make a purchase in one or more shops
         * @param {PurchaseShopDto} purchaseShopDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchase(purchaseShopDto: PurchaseShopDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchase(purchaseShopDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShopsApi - factory interface
 * @export
 */
export const ShopsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShopsApiFp(configuration)
    return {
        /**
         * Get a category from a shop
         * @summary Get a category from a shop
         * @param {string} shopId 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory(shopId: string, categoryId: string, options?: any): AxiosPromise<Category> {
            return localVarFp.getCategory(shopId, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a shop
         * @summary Get shop
         * @param {string} shopId 
         * @param {boolean} withCategories 
         * @param {string} appId Application Id to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShop(shopId: string, withCategories: boolean, appId: string, options?: any): AxiosPromise<Shop> {
            return localVarFp.getShop(shopId, withCategories, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Make a purchase in one or more shops
         * @summary Make a purchase in one or more shops
         * @param {PurchaseShopDto} purchaseShopDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchase(purchaseShopDto: PurchaseShopDto, options?: any): AxiosPromise<Category> {
            return localVarFp.purchase(purchaseShopDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShopsApi - object-oriented interface
 * @export
 * @class ShopsApi
 * @extends {BaseAPI}
 */
export class ShopsApi extends BaseAPI {
    /**
     * Get a category from a shop
     * @summary Get a category from a shop
     * @param {string} shopId 
     * @param {string} categoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopsApi
     */
    public getCategory(shopId: string, categoryId: string, options?: any) {
        return ShopsApiFp(this.configuration).getCategory(shopId, categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a shop
     * @summary Get shop
     * @param {string} shopId 
     * @param {boolean} withCategories 
     * @param {string} appId Application Id to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopsApi
     */
    public getShop(shopId: string, withCategories: boolean, appId: string, options?: any) {
        return ShopsApiFp(this.configuration).getShop(shopId, withCategories, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Make a purchase in one or more shops
     * @summary Make a purchase in one or more shops
     * @param {PurchaseShopDto} purchaseShopDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopsApi
     */
    public purchase(purchaseShopDto: PurchaseShopDto, options?: any) {
        return ShopsApiFp(this.configuration).purchase(purchaseShopDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StatsApi - axios parameter creator
 * @export
 */
export const StatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return all stats (public, private, internal) of the requested profile
         * @summary Get profile\'s stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set stats (public, private) of the requested profile. This operation replace the whole stats object, use it carefully (or use Update Stats)
         * @summary Set profile\'s stats
         * @param {UpdateStatsDto} updateStatsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setStats: async (updateStatsDto: UpdateStatsDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateStatsDto' is not null or undefined
            assertParamExists('setStats', 'updateStatsDto', updateStatsDto)
            const localVarPath = `/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStatsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update stats (public, private) of the requested profile. This operation replace only the specified fields in the request, other fields will not be updated.
         * @summary Update profile\'s stats
         * @param {UpdateStatsDto} updateStatsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStats: async (updateStatsDto: UpdateStatsDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateStatsDto' is not null or undefined
            assertParamExists('updateStats', 'updateStatsDto', updateStatsDto)
            const localVarPath = `/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication profile-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStatsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatsApi - functional programming interface
 * @export
 */
export const StatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatsApiAxiosParamCreator(configuration)
    return {
        /**
         * Return all stats (public, private, internal) of the requested profile
         * @summary Get profile\'s stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStats(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Stats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set stats (public, private) of the requested profile. This operation replace the whole stats object, use it carefully (or use Update Stats)
         * @summary Set profile\'s stats
         * @param {UpdateStatsDto} updateStatsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setStats(updateStatsDto: UpdateStatsDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Stats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setStats(updateStatsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update stats (public, private) of the requested profile. This operation replace only the specified fields in the request, other fields will not be updated.
         * @summary Update profile\'s stats
         * @param {UpdateStatsDto} updateStatsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStats(updateStatsDto: UpdateStatsDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Stats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStats(updateStatsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatsApi - factory interface
 * @export
 */
export const StatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatsApiFp(configuration)
    return {
        /**
         * Return all stats (public, private, internal) of the requested profile
         * @summary Get profile\'s stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options?: any): AxiosPromise<Stats> {
            return localVarFp.getStats(options).then((request) => request(axios, basePath));
        },
        /**
         * Set stats (public, private) of the requested profile. This operation replace the whole stats object, use it carefully (or use Update Stats)
         * @summary Set profile\'s stats
         * @param {UpdateStatsDto} updateStatsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setStats(updateStatsDto: UpdateStatsDto, options?: any): AxiosPromise<Stats> {
            return localVarFp.setStats(updateStatsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update stats (public, private) of the requested profile. This operation replace only the specified fields in the request, other fields will not be updated.
         * @summary Update profile\'s stats
         * @param {UpdateStatsDto} updateStatsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStats(updateStatsDto: UpdateStatsDto, options?: any): AxiosPromise<Stats> {
            return localVarFp.updateStats(updateStatsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatsApi - object-oriented interface
 * @export
 * @class StatsApi
 * @extends {BaseAPI}
 */
export class StatsApi extends BaseAPI {
    /**
     * Return all stats (public, private, internal) of the requested profile
     * @summary Get profile\'s stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public getStats(options?: any) {
        return StatsApiFp(this.configuration).getStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set stats (public, private) of the requested profile. This operation replace the whole stats object, use it carefully (or use Update Stats)
     * @summary Set profile\'s stats
     * @param {UpdateStatsDto} updateStatsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public setStats(updateStatsDto: UpdateStatsDto, options?: any) {
        return StatsApiFp(this.configuration).setStats(updateStatsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update stats (public, private) of the requested profile. This operation replace only the specified fields in the request, other fields will not be updated.
     * @summary Update profile\'s stats
     * @param {UpdateStatsDto} updateStatsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public updateStats(updateStatsDto: UpdateStatsDto, options?: any) {
        return StatsApiFp(this.configuration).updateStats(updateStatsDto, options).then((request) => request(this.axios, this.basePath));
    }
}


